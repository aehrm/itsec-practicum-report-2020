#include <string.h>
#include "hash_result.h"

int hash_result_rb_insert_cmp(rb_tree *tree, rb_node *node_a, rb_node *node_b) {
    hash_result *result_a = (hash_result*) node_a->value;
    hash_result *result_b = (hash_result*) node_b->value;
    result_container *container = result_a->container;

    if (result_a == result_b) return 0;

    for (int i = 0; i < container->prefix_len; i++) {
        int ret = (result_a->prefix[i] > result_b->prefix[i]) - (result_a->prefix[i] < result_b->prefix[i]);
        if (ret != 0) return ret;
    }

    return 1;
}

int hash_result_rb_test_cmp(rb_tree *tree, rb_node *node_a, rb_node *node_b) {
    hash_result *result_a = (hash_result*) node_a->value;
    hash_result *result_b = (hash_result*) node_b->value;
    result_container *container = result_a->container;

    for (int i = 0; i < container->prefix_len; i++) {
        int ret = (result_a->prefix[i] > result_b->prefix[i]) - (result_a->prefix[i] < result_b->prefix[i]);
        if (ret != 0) return ret;
    }

    return 0;
}


void container_init(result_container *container, unsigned char *data, int data_len)
{
    container->results_num = data_len / container->prefix_len;
    hash_result **results = (hash_result**) malloc(container->results_num * sizeof(hash_result*));
    container->results = results;

    for (int i = 0; i < container->results_num; i++) {
        hash_result *obj = (hash_result*) malloc(sizeof *obj);
        obj->prefix = data + i*(container->prefix_len);
        obj->hash = NULL;
        obj->preimage = NULL;
        obj->container = container;
        results[i] = obj;
    }
}

hash_result* container_tree_test_hash(result_tree *tree, unsigned char *hash, unsigned char *preimage)
{
    unsigned char* prefix = tree->container->get_prefix(hash);
    hash_result search_obj = { .prefix = prefix, .container = tree->container };

    // find matching node
    hash_result *node = (hash_result*) rb_tree_find(tree->rb_tree, &search_obj, &hash_result_rb_test_cmp);

    if (node == NULL) {
        return NULL;
    }

    rb_tree_remove(tree->rb_tree, node);
    node->hash = (unsigned char*) malloc(tree->container->hash_len * sizeof(unsigned char));
    memcpy(node->hash, hash, tree->container->hash_len);
    node->preimage = (unsigned char*) malloc(tree->container->preimage_len * sizeof(unsigned char));
    memcpy(node->preimage, preimage, tree->container->preimage_len);

    return node;
}

int container_tree_remaining(result_tree *tree)
{
    return rb_tree_size(tree->rb_tree);
}

result_tree* container_create_trees(result_container *container, int n)
{
    result_tree* trees = (result_tree*) malloc(n * sizeof(result_tree));
    int split_index = 0;
    for (int i = 0; i < n; i++) {
        rb_tree* tree = rb_tree_create(&hash_result_rb_insert_cmp);
        int portion_num = (container->results_num - split_index) / (n - i);

        for (int j = split_index; j < split_index + portion_num; j++) {
            rb_tree_insert(tree, container->results[j]);
        }

        trees[i] = { .rb_tree = tree, .container = container };

        split_index += portion_num;
    }

    return trees;
}
