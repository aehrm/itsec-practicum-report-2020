\documentclass[10pt,a4paper,twocolumn]{article}

\usepackage{unicode-math}
\setmainfont{Libertinus Serif}
\setmathfont{Libertinus Math}

\usepackage{polyglossia}
\setdefaultlanguage{english}

\usepackage{booktabs,makecell}
\usepackage[binary-units=true]{siunitx}
\usepackage{csquotes}
\usepackage[labelfont=bf]{caption}
\usepackage{enumitem}
\setlist{itemsep=0.3ex}
\setlist[enumerate]{label = (\alph*)}
\usepackage[backend=biber,style=alphabetic]{biblatex}
\usepackage{stfloats}
\usepackage{tikz,pgfplots}
\pgfplotscreateplotcyclelist{mylist}{%
    draw={rgb,1:red,0.368417;green,0.506779;blue,0.709798},thick\\%
    draw={rgb,1:red,0.880722;green,0.611041;blue,0.142051},thick\\%
    draw={rgb,1:red,0.560181;green,0.691569;blue,0.194885},thick\\%
    draw={rgb,1:red,0.922526;green,0.385626;blue,0.209179},thick\\%
    draw={rgb,1:red,0.528488;green,0.470624;blue,0.701351},thick\\%
}

\output\expandafter{\the\output\floatfix}

\makeatletter
\def\floatfix{%
\expandafter\ifx\csname r@x@one\endcsname\relax
\else
\ifnum\c@page=\numexpr\expandafter\expandafter\expandafter
              \@secondoftwo\csname r@x@one\endcsname-1\relax
\aftergroup\figone
\fi
\fi}
\makeatother


\title{Evaluation of countermeasures against malicious data inclusion attacks in Bitcoin}
\author{Anton Ehrmanntraut}

\renewenvironment{abstract}
{\begin{quote}
\noindent {\bfseries \abstractname.}}
{\end{quote}
}

\begin{document}

\raggedbottom
\maketitle
\begin{abstract}
\end{abstract}

\section{Introduction}

\section{Motivation and Scope}

% ignore input-script-insertions <-> assume non-standard scripts banned
% P2SH-method uses non-standard script and is not suited for analysis(?)
% required unlocking input however provably is a  public key

% P2MS??

\section{Approach}

\section{Increased cost of data inclusion}

After having demonstrated the possibility to circumvent the proposed countermeasure by brute force, this section attempts to evaluate the effectiveness of that countermeasure. 
Specifically, we assume a (not neccessarily adversarial) user, attempting to use the blockchain as data storage.
We will see that the user's chosen prefix length for the partial collissions directly determines the inclusion cost, hence we first model the inclusion cost mathematically. Then, by giving further estimations of essential parameters, we are able to predict by which factor the proposed countermeasure using proof-of-ownership signatures increases inclusion cost with respect to current, unprotected situation using fake addresses. 

\subsection{Modelling inclusion cost}

\begin{table*}[t]
    \centering
    \begin{tabular}{llr<{\,\si{\watt}}S[table-format=4.0,table-number-alignment=right]@{\,}rS[table-format=1.1e-2,table-number-alignment=right]r}
        \toprule
        \textbf{Method} & \textbf{Hardware} & \multicolumn{1}{r}{\textbf{est. wattage}} &\multicolumn{2}{r}{\textbf{est. freq.}} & \multicolumn{1}{r}{\textbf{$c$ in USD}} & \textbf{ref.}\cr
        %\midrule
        % TODO personal measures
        \midrule
        P2PKH & AMD RX 480  & 225 & 60 & \si{\mega\hertz} & 1.4e-13 &  Aug. 2016\cr %https://en.bitcoin.it/w/index.php?title=Vanitygen&type=revision&diff=61424&oldid=58554
              & GTX 1060  & 120 & 40 & \si{\mega\hertz} & 1.1e-13 &  Mar. 2018\cr
              & GTX 1080 TI  & 250 & 100 & \si{\mega\hertz} & 9.0e-14 &  Feb. 2019\cr
        \midrule
        P2SH & GTX 1080 TI & 250 & 2400 & \si{\mega\hertz} & 3.8e-15 & \cr % https://gist.github.com/epixoip/ace60d09981be09544fdd35005051505
        & RTX 2080 TI & 280 & 3800 & \si{\mega\hertz} & 2.7e-15 & \cr % https://gist.github.com/epixoip/ace60d09981be09544fdd35005051505
        & RTX Titan & 300 & 4300 & \si{\mega\hertz} & 2.5e-15 & \cr% https://gist.github.com/Chick3nman/5d261c5798cf4f3867fe7035ef6dd49f
        \bottomrule
    \end{tabular}
    \caption{User's reports of their brute-force frequencies on specific hardware. For the P2PKH method, frequency was directly taken from reported \emph{Vanitygen} speed. For the P2SH method, SHA256 hash frequency reported from \emph{Hashcat} was divided by factor 2, as explained in the respective section.
    We estimate cost parameter $c$ for the {P2PKH} by first researching estimated power consumption of the GPU under full load, and assuming energy cost of \num{.13} USD per \si{\kilo\watt\hour}.}
    \label{table:cost}
\end{table*}

Essentially, the choice of a suitable prefix length is a trade-off:
On the one hand, the number of required keypairs, and hence needed transaction fees, are inversely proportional to the chosen prefix length;
on the other hand, the probability for a partial collision decreases exponentially with respect to the prefix length, and in turn, computation cost increases exponentially.

To precicely model the cost of an inclusion of an arbitrary payload into the blockchain, restricted with the proposed countermeasure, let us denote 
\begin{itemize}
    \item prefix length with $n$,
    \item payload length with $N$,
    \item cost of a single hash operation with $c$,
    \item transaction fee for a single address with $f$.
\end{itemize}
Moreover, we denote $p=N/n$ as the number of required addresses, (or equivalently, the number of payload fragments) and $X$ as the random variable of required hash operations.
From this, total cost $C$ of an inclusion can be given with
\[ C =  c X + fp = c X + fN/n . \]

To precicely determine random variable $X$, we remind ourselves of the general iterative procedure of the brute-force algorithm:
In each iteration, the algorithm determines a keypair such that its prefix matches one of the payload fragments not yet assigned a keypair, and then assigns that fragment the keypair.
That is, in iteration $i$, the algorithm chooses private keys randomly, until generated public key paritially collides with one of the $p-i$ remaining unassigned payload fragments.
In the worst case, all fragments are pairwise different%
%\footnote{This is to be expected for sufficiently large prefix length $n$:}%
, hence one iteration can be viewed as repeated independent Bernoulli trials until success (i.e.\@ partial collision found), with success probability $(p-i)/2^n$.  
Refering to required hashes in iteration $i$ with $X_i$, we thus observe that the random variable $X_i$ follows a geometric distribution with parameter $(p-i)/2^n$.
For the total number of required hash operations $X$, we reach
\[ X = \sum_{i=1}^{p} X_i, \quad E[X] = \sum_{i=1}^{p} E[X_i] = \sum_{i=1}^{p}\frac{2^n}{i} = 2^n\, H_p, \]
and conclude for the expected total cost $C$
\begin{equation}
    E[C] = 2^n\, H_p\,c + fp.\label{eq:totalcost}
\end{equation}

%Figure \ref{fig:xxx} plots the expected total cost with respect to chosen prefix length, using $N=\SI{1000}{\byte}$, and sensible values for $f$, $c$, assuming the {P2PK} method (cf. next section).
%We can clearly observe a minimum value, the inverse proportionality in bit ranges left of highlighted minimum value, and the exponential growth right of the minimum value.

\subsection{Estimation of parameters}

% TODO intros, Hardware?

%The software introduced in previous section was used to measure values for $c$, separately for each inclusion method ({P2PK, P2PKH, P2SH}).
%Additionally, we can give further estimates for cost $c$ indirectly for the inclusion method {P2PKH} and {P2SH}.

Before we can determine the cost increasse caused by the proposed countermeasure, we need to give sensible estimations for the cost parameters $c$ and $f$ involved in the previously stated cost model (\ref{eq:totalcost}).
While fees $f$ for publishing an address are directly determined by the miners' transaction fee rate, hashing cost depends on the efficiency of the hardware used for the brute-force process.
For this, we estimate the paramter indirectly using hash-rates reported by users of the tools \emph{Vanitygen} and \emph{Hashcat}.
%Since the P2PK method turns out to be the least effective, the omit an estimation of $c$ for this method.

\paragraph{Transaction fees}


\begin{table*}[t]
    \centering
    \begin{tabular}{lrrrS[table-format=2.2,table-alignment=right]rS[table-format=1.2e-1,table-alignment=right]}
        \toprule
        & \llap{script size} & max. payload & max. addresses & {tx bytes} & {non-dust amount} & {}\cr
        Type & in byte & length in byte & per tx &  {per address} & {per address in sat} & {$f$ in USD}\cr
        \midrule
        % TODO recalculate with input script length 72
        P2PK & 35 & 32 & 2267 & 44.10 & 546 & 7.78e-2\cr
        1-of-3 P2MS  & 105 & 32 & 2625 & 38.09& 182 & 4.44e-2\cr
        P2PKH & 25 & 20 & 2934 & 34.08 & 546 & 6.99e-2\cr
        P2SH & 23 & 20 & 3117 & 32.08& 546 & 6.83e-2\cr
        \bottomrule
    \end{tabular}
    % omit script size/payload size?
    \caption{Overview of the different trasaction types. 
        First column denotes the scripts size for a trasaction output, holding an address (resp. three addresses in the case of P2MS).
        Second column denotes the maximum payload length per address (in particular, the first byte of a 33-byte public key is a fixed prefix).
        Third column gives how many addresses can be gathered in a single transaction (not exceeding the size limit of \SI{100}{\kilo\byte}),
        fourth column the average bytes required per address in that particular transaction.
        Note that non-dust amount (546 sat) is counted by output, hence P2MS non-dust amount per address is one third.
    To compute value $f$, we multipy the transaction bytes required per address (column 5) with current miner's transaction fees (10 sat per byte), and add the smalles non-dust amount (column 6), converted at current exchange rate of \num{7.9e3} USD per bitcoin.}
\end{table*}

The fees required for publishing the address into the blockchain, i.e. parameter $f$, can easily estimated using average bytes required for a transaction output.
For this, we construct the largest possible transaction  using a single P2PK coinbase input to fund the outputs with non-dust burns, and adding outputs until reaching network's size limit of $\SI{100}{\kilo\byte}$.
Multiplying with miner's transaction fees, and adding smallest non-dust burn amount (dependent on method) yields the value for paramter $f$.
Table \ref{table:} gives this parameter in absolute values for all three methods, using transaction fees and Bitcoin price at point of publication.
That is, network's transaction fee of 10 sat per byte, and \num{7.9e3} USD per bitcoin.
Note that the P2MS strategy, arranging pubkeys in 1-of-3 multisig outputs, is currently the least expensive one in terms of fees required.
Even though multisig outputs cause more overhead in the constructed transaction, required non-dust amount is counted per output, hence, grouping three pubkeys into one transaction output saves on burnt bitcoins.

Since the P2PK method performs worst in this regard, we discard this method and focus on the related method P2MS, besides the fact that these two methods only differ in their transaction construction, yet are identical in their brute-force procedure.

\paragraph{P2PKH hash cost estimation}
For the {P2PKH} method, we can rely on user reports on their performance using the tool \emph{Vanitygen}, which allows users to create vanity addresses.
These Bitcoin addresses contain a human-readable prefix in their Base-58 representation.
Similiarly to the presented tool in previous section, \emph{Vanitygen} brute-forces private keys, until the hashed public key has the desired prefix;
this public key hash is preciely the one used to create {P2PKH} hashes.

Hence, due to the computational similarity, it seems reasonable to estimate possible computational cost for the {P2PKH} method from reported frequencies of \emph{Vanitygen} on selected hardware.
We assume that the computational effort of testing if a public key hash partially collides with one of the remaining unassigned payloads is negleglible.
In fact, the \emph{OpenCL} code used for the (usually faster performing) GPU code direcly builds on top of the one used in \emph{Vanitygen}.
Table \ref{table:cost} gives estimations for cost $c$ bases on selected user reports.

\paragraph{P2SH hash cost estimation}
In a similar matter, one can use the performances in computing {SHA256} digests as estimation for the cost of the {P2SH} method.
As was outlined in previous section, the brute-force procedure for the {P2SH} method constructs from nonce candidate $x$ a 57-byte long redeem script $S(x)$, and computes the {P2SH} address as the hash digest 
\begin{equation}
    x \mapsto \text{{RIPEMD160}}(\text{{SHA256}}(S(x))).\label{eq:p2sh-hash}
\end{equation}
% http://bench.cr.yp.to/results-hash.html#amd64-skylake
% https://en.wikipedia.org/wiki/Comparison_of_cryptographic_hash_functions
% KL15
The primitive hash functions {RIPEMD160} and {SHA256} are highly similar in architecture and performance; their respective Merkle–Damgård transforms also operate on the same block size of 512 bits.
Therefore, the effort required in above procedure (\ref{eq:p2sh-hash}) can be considered twice as large as one {SHA256} digest computation (in the sense of input length $\leq\!\SI{512}{\bit}$). 

% hashcat
Likewise to previous estimation using \emph{Vanitygen}, we can use hash frequencies published by users of the password cracking tool \emph{Hashcat}.
Dividing the reported SHA256 hash frequency by factor 2 thus yields an approximate frequency accomplishable for the P2SH brute-force procedure.
(We tacitly assume that the GPU can be programmed to perform RIPEMD160 calculations in similar speed.)
Again, refer to table \ref{table:cost} for estimations on cost $c$ bases on selected user reports.
Both the P2PKH and the P2SH method perform the same hash operations, only the former has to additionally perform a elliptic-curve addition.

Comparing the two methods, we can already observe that elliptic-curve arithmetics involved in the P2PK(H)/P2MS method heavily dominates the brute-force process.
We therefore omit a precise cost estimation of the P2PK/P2MS method, and can assume that savings made by omitting the RIPEMD160/SHA256 operations (in comparision to the P2PKH method) are neglegible.

\subsection{Comparison with state-of-the-art methods}

\begin{figure*}[tb]
    \centering
    \pgfplotstableread[col sep=comma, ignore chars={"}]{graph1.csv}{\totalcostplot}
    \begin{tikzpicture}[
            mark size=1.5pt
        ]
        \begin{semilogyaxis}[
                height=8cm,
                width=13cm,
                grid=both,
                xmin=5,
                xmax=55,
                ymax=1,
                log ticks with fixed point,
                ymin=1e-2,
                cycle list name=mylist,
                legend style={at={(0.5,0.95)},
		anchor=north,legend columns=2},
                xlabel={Prefix length $n$ in bits},
                ylabel={Expected cost per kilobyte in USD}
            ]

            \addplot+[mark=x] table [x={n}, y={p2pkh}] {\totalcostplot};
            \addlegendentry{P2PKH}
            \addplot+[mark=o] table [x={n}, y={p2ms}] {\totalcostplot};
            \addlegendentry{P2MS}
            \addplot+[mark=square] table [x={n}, y={p2sh}] {\totalcostplot};
            \addlegendentry{P2SH}
            \addplot+[dashed,mark=none] table [x={n}, y={p2fms}] {\totalcostplot};
            \addlegendentry{fake multisig}
        \end{semilogyaxis}
    \end{tikzpicture}
    \caption{Log-linear plot of expected total cost $\mathrm{E}[C]$ (see equation \ref{eq:totalcost}) with $N=\SI{10}{\kilo\byte}$ for inclusion methods P2PKH ($c=\num{1.0e-13}$ USD, $f=\num{6.99e-2}$ USD), P2MS ($c=\num{1.0e-13}$ USD, $f=\num{4.44e-2}$ USD), P2SH ($c=\num{3.0e-15}$ USD, $f=\num{6.83e-2}$ USD). For comparison, dotted line indicates constant efficiency achievable using fake addresses in multisig outputs.}
\end{figure*}

This section compares the impact of the proposed inclusion method with the current situation, having no countermeasures.
To begin with, we choose following rough but sensible estimates for computation cost parameter $c$ for methods P2MS, P2PKH, P2SH, based on our observations from previous section.
We estimate $c_\text{ms}=c_\text{pkh}=\num{1.0e-13}$ USD, $c_\text{sh} = \num{3.0e-15}$ USD.
Also stated in previous section, fee parameter $f$ directly follows from Bitcoin price and mining fees, and is displayed in table \ref{table:}.

As was given in the introduction, the best present method of including arbitrary data uses fake public keys (in their extended 65 byte representation) arranged in 1-of-3 multisig outputs, not being inhibited by any countermeasure requiring proof signatures.
Relative cost of inclusion using this state-of-the-art method can easily be estimated using same formula (\ref{eq:totalcost}), assigning $c=0$, maximum prefix size $n=\SI{65}{\bit}$, and computing $f$ identically to previous procedure, considering \SI{70.16}{\byte} per 65-byte-address/-pubkey.
This gives us a constant cost efficiency of \num{1.07e-3} USD per byte as benchmark.

Figure \ref{fig:plot} plots the expected cost per byte payload, using $N=\SI{10}{\kilo\byte}$ and previously stated parameters, for each method.
As comparison, the constant relative cost of the state-of-the-art method is highlighted by the dashed horizontal line. 

\enlargethispage{\baselineskip}
We confirm that determiniong the most cost-effetive prefix length corresponds to finding the local minimum of the cost function.
Futhermore, the plot supports the trade-off nature of the problem: left of the maximum point, cost increases proportional due to more addresses required; cost right of the maximum point is dominated by the exponentially increasing brute force computation cost.

By routine exhaustion, we give minimum cost per kilobyte payload in table \ref{table:},
and obtain following result: 
defending the Bitcoin network against unwanted data inclusion using proof-of-ownership signatures could allow for an 8-fold increase (resp.\@ 11-fold increase if restricted to public-key-based addresses) of inclusion cost, at current situation.

Nevertheless, it needs to be highlighted that optimal cost efficiency can only be obtained using significant computational power.
For example, using the fastest GPU for the P2SH inclusion method from table \ref{table:}, including the \SI{10}{\kilo\byte} already requires 72 hours of computation.
In fact, real-time inclusion using non-specialized hardware seems out of reach for prefix lenghts as low as 28 bits, requiring more than a minute of computation time on a typical personal computer for payload length of $N=\SI{100}{\byte}$ (assuming hash frequency of \SI{10}{\mega\hertz}).

\begin{table}
    \centering
    \begin{tabular}{lrS[table-format=0.4,table-alignment=right]S[table-format=2.2,table-alignment=right]}
        \toprule
        & {\textbf{\llap{opt. prefix}}} & {\textbf{exp. cost in}} & \textbf{{rel. increase}}\cr
        & {\textbf{length}} & {\textbf{USD per kB}} & {\textbf{w.r.t.\@ P2FMS}}\cr
        \midrule
        P2PKH & 42 & 0.137 & 12.7\cr
        P2MS  & 42 & 0.0882 & 11.2\cr
        P2SH & 47 & 0.120 & 8.21\cr
        \bottomrule
    \end{tabular}
    \caption{Minimum point $n$ and minimum value $\mathrm{E[C]}$ from plot in figure \ref{fig:}. Rightmost column gives the relative increase with respect to the constant efficiency achievable using fake addresses in multisig outputs.}
\end{table}



\section{Analytical considerations}
% TODO attacker model
% TODO motivation

% TODO wrong differentiation
%\dots

%First, we formulate $r(n)$ as the expected relative cost \emph{per bit payload} with respect to prefix length $n$ from above equation (\ref{eq:totalcost}), fixing parameters $N$, $c$, $f$, and consider the continuation $r\colon \mathbb{R}_+ \to \mathbb{R}$ onto the reals, that is
%\[ 
    %r(n) = \left(\frac{2c2^{n}}{p^2+p} + fp\right)/N = \frac{2c 2^{n} n^2}{N^2 (N+n)}+\frac{f}{n}. 
%\]
%Thus function $r$ constitutes a continuous real-valued function, and we can find optimal $n^*$ yielding minimum cost per bit payload using usual derivative test.
%Since $N\gg n\gg 2$, we approximate
%\begin{align*}
    %\frac{\partial}{\partial n} r(n)   &\approx \frac{\partial}{\partial n} \left( \frac{2c 2^{n} n^2}{N^3}+\frac{f}{n} \right)\\
                                         %&= \frac{2c 2^{n} n (n \log (2)+2)}{N^3}-\frac{f}{n^2}\\
                                         %&\approx \left(\frac{2 \log (2)\,c}{N^3}\right) 2^{n} n^2 -\frac{f}{n^{2}}.
%\end{align*}
%Solving for $\partial/\partial n\, r(n^*)=0$, we get minimum cost at $n=n^*$, that is, with $\alpha, \beta \ll 1$ constants, $W$ the \emph{Lambert $W$ function},
%\[ r(n^*) \approx f/n^* = \frac{\alpha\cdot f}{W\left(\beta\cdot\sqrt[4]{f N^3/c}\right)}. \]
%is the approximative optimal relative cost, depending on $f$, $N$, $c$.
%Assuming $W\in \mathcal{O}(\log)$, we observe
%\begin{enumerate}
    %\item relative cost is effectively linear with respect to transaction fee $f$,
    %\item halvening the computation cost allows for a constant number of additional payload bits to be included, having same fixed budget; $1/r(n^*) \in \mathcal{O}(-\log(c))$;
    %\item even though total cost $N\cdot r(n^*)$ of data is asymtotically sublinear in $\mathcal{O}(N / \log(N))$, for any reasonable quantity $N$ total cost grows effectively linear.
%\end{enumerate}
%We discuss the consequences of these findings in the last chapter.
% TODO cost increase w.r.t. to the environment variables (exponential growth of efficiency)

\section{Cost of malicious attack}

In this section, we address the problem of data inclusion from the perspective of a malicious adversary.
As was outlined in the introduction, deliberate inclusion of problematic data into the Blockchain, such as copyright-protected, illegal, or politically sensitive content, could render the possession of the Blockchain illegal in most jurisdictions.
Hence, due to persistency of the blockchain, this malicious inclusion harms every participant in Bitcoin's network, and might make participation even legally impossible.

% TODO motivation, scale of resources availiable to the attacker(?)
Since Bitcoin's concensus mechanism is the basis for its security, we assume a consensus attack (i.e. \enquote*{51\%-attack} – controling more than honest miner's hashrate) as an upper bound for a disruptive attack against Bitcoin's network.
Therefore, we evaluate the cost of such an attack including malicious content \emph{in terms of computational power}.
Moreover, it seems adequate to measure the required computational power \emph{relative to the concensus attack}.

% \paragraph{} TODO
As we have already seen, data inclusion using {P2SH} addresses via brute-forcing many redeem scripts is the computationally least expensive method.
To compare the computational cost to Bitcoin's mining process, we argue that the expense of hashing a single {P2SH} transaction is comparable to hashing a single block header during the Proof-of-Work mining process.

% TODO

%Only as a theoretical consideration, we can build an additional estimation on the basis of Bitcoin mining hardware.
%The emergence of mining hardware developed using application-specific integrated circuits (ASIC) proved that SHA-256 hashes can be computed with an efficiency magnitudes better than traditional GPU-based methods.
%Nevertheless, reliable numbers for the efficiency of such ASIC units seem to only appear in the context of Bitcoin mining, therefore, we focus on such mining hardware.
%It has to be emphasized that the advertized strong computation power of such ASIC units cannot directly be utilized for the task of performing the P2SH computation (\ref{eq:p2sh-hash}), and the determined numbers only serve as an indirect estimation of the theoretical efficiency permitted by application-specific integrated circuits.

In comparison to the P2SH hash procedure (\ref{eq:p2sh-hash}), Proof-of-Work mining constructs from nonce candidate $x$ the 80-byte long block header $H(x)$, and performs a double SHA-256 hashing, i.e. 
\begin{equation}
    x \mapsto \text{{SHA256}}(\text{{SHA256}}(H(x))),\label{eq:pow-hash}
\end{equation}
to test against network target.
We alread argued in section \ref{sec:parameter-estimation} that P2SH hashing (\ref{eq:p2sh-hash}) requires computational work comparable to two SHA256 calculations; from above construction (\ref{eq:pow-hash}) follows the stated claim that computing a P2SH hash is approximately as hard as computing a Proof-of-Work hash.

This conclusion is not immediate due to following apparent caveat: block headers $H(x)$ are substantially longer than redeem scripts $S(x)$.
As the former input is split into two 512-bit blocks for hashing, computation requires two invocations of the respective {SHA256} compression function in the Merkle–Damgård transform.
However, the first 512 bits of input $H(x)$ remain constant with respect to chosen nonce $x$, and in general, during mining, the \enquote*{mid-state} after applying the first compression is precomputed and stored.
Hence, computations of $\text{{SHA256}}(S(x))$ and $\text{{SHA256}}(H(x))$ both require only a single invocation of the compression function.
% https://link.springer.com/chapter/10.1007/978-3-662-44893-9_12

% TODO argue for bandwith limit imposed by block frequency (1 TX per block = 3117 outputs per block = 3117*n bits per 10 minutes)

\section{Discussion and Conclusion}

% https://link.springer.com/article/10.1007/s11227-018-2317-6

\end{document}
